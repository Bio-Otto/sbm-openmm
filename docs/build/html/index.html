
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>sbmOpenMM Documentation &#8212; sbmOpenMM 0.0.1 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="toctree-wrapper compound">
</div>
<div class="section" id="sbmopenmm-documentation">
<h1>sbmOpenMM Documentation<a class="headerlink" href="#sbmopenmm-documentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Structure Based Models (SBMs) are representations of protein systems based on simplifications made over classical Molecular Dynamics (MD) force fields. Their are based on the energy landscape theory of protein folding and the principle of minimal frustration. The models maintain protein structures by focusing on chemical contacts formed at the native protein configuration, ignoring other non-native contacts. This allows for simpler force field definitions which capture essential protein dynamics at a much lower computational expense than traditional MD simulations.</p>
<p>sbmOpenMM is a Python library that offers flexibility to set up SBMs using the MD framework of OpenMM toolkit. It automates the creation of openmm.system classes that contain the necessary force field parameters to run molecular dynamics simulations using a protein structure and a contact map as the only necessary inputs.</p>
<p>sbmOpenMM is divided in three main classes:</p>
<ol class="arabic simple">
<li><p>geometry</p></li>
<li><p>models</p></li>
<li><p>system</p></li>
</ol>
<p>The first class, geometry, contains methods to calculate the geometrical parameters from the input structures. These parameters are used to define the input conformation as the global minimum configuration in the potential energy function. The second class, models, allows to easily set up predefined SBM models, that encompass coarse grained, all atom and multi basin potentials. The third class, system, is the main class that holds all the methods to define, modify and create SBMs to be simulated with OpenMM.</p>
<p>The library is open-source and offers flexibility to create custom SBMs or to modify the predefined topology based models included in it.</p>
</div>
<div class="section" id="sbm-models">
<h2>SBM Models<a class="headerlink" href="#sbm-models" title="Permalink to this headline">¶</a></h2>
<p>The models class of sbmOpenMM contains three methods for automatic setting up predefined SBM potentials. It works by initializing a system class with the necessary force field parameters, derived from the input files, to set up one of the possible models which are detailed next:</p>
<div class="section" id="coarse-grained-alpha-carbon-ca-model">
<h3>Coarse grained, alpha-carbon (CA), model<a class="headerlink" href="#coarse-grained-alpha-carbon-ca-model" title="Permalink to this headline">¶</a></h3>
<p>The coarse grained method represents the protein system as beads centered at the alpha carbons of each residue in the protein. It uses harmonic potentials to hold the covalent connectivity and geometry of the beads. Torsional geometries are modeled with a periodic torsion potential. Native contacts are represented through the use of Lennard-Jones potentials that allow to form and break non-bonded interactions, permitting complete and local unfolding of the structures.</p>
<p>To create a CA model, call:</p>
<p>sbmOpenMM.models.getCAModel(pdb_file, contacts_file)</p>
<p>Here, pdb_file is the path to the PDB format structure of the protein and  contacts_file is the path to the contact file containing only the CA atoms of the system. This last file should be numbered considering the CA atoms consecutively.</p>
<p>The force field equations are:</p>
<div class="math notranslate nohighlight">
\[H_A = \sum_{bonds}V_{bond}+\sum_{angles}V_{angle}+\sum_{torsions}V_{torsion}+\sum_{contacts}V_{LJ_{12-10}}+\sum_{non-contacts}V_{LJ_{12}}\]</div>
<div class="math notranslate nohighlight">
\[V_{bond} = \frac{k_b}{2}(r-r_0)^2\]</div>
<div class="math notranslate nohighlight">
\[V_{angle} = \frac{k_a}{2}(\theta-\theta_0)^2\]</div>
<div class="math notranslate nohighlight">
\[V_{torsion} = k_t(1-cos(\phi-\phi_0))+\frac{1}{2}(1-cos(3(\phi-\phi_0))))\]</div>
<div class="math notranslate nohighlight">
\[V_{LJ_{12-10}} = \epsilon_{c}(5(\frac{\sigma_{ij}}{r})^{12}-6(\frac{\sigma_{ij}}{r})^{10})\]</div>
<div class="math notranslate nohighlight">
\[V_{LJ_{12}} = \epsilon_{nc}(\frac{\sigma_{nc}}{r})^{12}\]</div>
<p>Here the default values are <span class="math notranslate nohighlight">\(k_b=20000\ kJ/(mol \cdot nm^2)\)</span>, <span class="math notranslate nohighlight">\(k_a=40\ kJ/(mol \cdot rad^2)\)</span>, <span class="math notranslate nohighlight">\(k_t=1.0\ kJ/mol\)</span>, <span class="math notranslate nohighlight">\(\epsilon_{c}=1.0\ kJ/mol\)</span>, <span class="math notranslate nohighlight">\(\epsilon_{nc}=1.0\ kJ/mol\)</span> and <span class="math notranslate nohighlight">\(\sigma_{nc}=0.4\ nm\)</span>. The geometric parameters are set to the calculated structural values in the input structure, with <span class="math notranslate nohighlight">\(r_0\)</span> the equilibrium bond distance in nanometers, <span class="math notranslate nohighlight">\(\theta_0\)</span> the equilibrium angle length in radians, <span class="math notranslate nohighlight">\(\phi_0\)</span> the equilibrium torsional angle in radians and <span class="math notranslate nohighlight">\(\sigma_{ij}\)</span> the equilibrium contact distance in nanometers. The variable <span class="math notranslate nohighlight">\(r\)</span> represents, accordingly, the current bond or (non)contact distance in nanometers, <span class="math notranslate nohighlight">\(\theta\)</span> the current angle length in radians and <span class="math notranslate nohighlight">\(\phi\)</span> the current torsional angle in radians.</p>
<p>It is possible to use a <span class="math notranslate nohighlight">\(V_{LJ_{12-10-6}}\)</span> potential for the native contact interactions, defined as:</p>
<div class="math notranslate nohighlight">
\[V_{LJ_{12-10-6}} = \epsilon_{c}(13(\frac{\sigma_{ij}}{r})^{12}-18(\frac{\sigma_{ij}}{r})^{10}+4(\frac{\sigma_{ij}}{r})^{6})\]</div>
<p>This potential gives a small energy barrier for contact formation/breaking that emulates a “desolvation effect”. To use this potential as the native contact energy function, instead of the <span class="math notranslate nohighlight">\(V_{LJ_{12-10}}\)</span> potential, give the option contact_force =’12-10-6’ to the sbmOpenMM.models.getCAModel() method.</p>
<p>Note that even if the units for the force constants are given in real physical units (e.g. <span class="math notranslate nohighlight">\(kJ/mol\)</span>), this is just to match the variables used by OpenMM. The models are not parametrized to equate this real physical values and comparison with experiments will require further adjustment to the energy unit system.</p>
</div>
<div class="section" id="all-heavy-atoms-aa-model">
<h3>All-heavy-atoms (AA) model<a class="headerlink" href="#all-heavy-atoms-aa-model" title="Permalink to this headline">¶</a></h3>
<p>The all-atom model represents the protein system with all its heavy atoms (i.e. excluding hydrogens). It uses harmonic potentials to hold the covalent connectivity, geometry and chirality of the protein residues. Periodic torsional potentials are used to maintain dihedral geometries of backbones and side chains. Native contacts are represented through the use of Lennard-Jones potentials that allow to form and break non-bonded interactions, permitting complete and local unfolding of the structures.</p>
<p>The method to create an AA model is:</p>
<p>sbmOpenMM.models.getAllAtomModel(pdb_file, contacts_file)</p>
<p>Here, pdb_file is the path to the PDB format structure of the protein and  contacts_file is the path to the contact file containing only the non-hydorgen atoms of the protein system.</p>
<p>The force field equations are:</p>
<div class="math notranslate nohighlight">
\[H_A = \sum_{bonds}V_{bond}+\sum_{angles}V_{angle}+\sum_{torsions}V_{torsion}+\sum_{impropers}V_{improper}+\sum_{planars}V_{planar}+\sum_{contacts}V_{LJ_{12-10}}+\sum_{non-contacts}V_{LJ_{12}}\]</div>
<div class="math notranslate nohighlight">
\[V_{bond} = \frac{k_b}{2}(r-r_0)^2\]</div>
<div class="math notranslate nohighlight">
\[V_{angle} = \frac{k_a}{2}(\theta-\theta_0)^2\]</div>
<div class="math notranslate nohighlight">
\[V_{torsion} = k_t(1-cos(\phi-\phi_0))+\frac{1}{2}(1-cos(3(\phi-\phi_0))))\]</div>
<div class="math notranslate nohighlight">
\[V_{improper} = \frac{k_i}{2}(\chi-\chi_{0})^2\]</div>
<div class="math notranslate nohighlight">
\[V_{planar} = \frac{k_p}{2}(\chi-\chi_{0})^2\]</div>
<div class="math notranslate nohighlight">
\[V_{LJ_{12-10}} = \epsilon_{c}(5(\frac{\sigma_{ij}}{r})^{12}-6(\frac{\sigma_{ij}}{r})^{10})\]</div>
<div class="math notranslate nohighlight">
\[V_{LJ_{12}} = \epsilon_{nc}(\frac{\sigma_{nc}}{r})^{12}\]</div>
<p>Here the default values are <span class="math notranslate nohighlight">\(k_b=10000\ kJ/(mol \cdot nm^2)\)</span>, <span class="math notranslate nohighlight">\(k_a=80\ kJ/(mol \cdot rad^2)\)</span>, <span class="math notranslate nohighlight">\(k_i=10.0\ kJ/(mol \cdot rad^2)\)</span>, <span class="math notranslate nohighlight">\(k_p=20.0\ kJ/(mol \cdot rad^2)\)</span>, <span class="math notranslate nohighlight">\(\epsilon_{nc}=0.1\ kJ/mol\)</span> and <span class="math notranslate nohighlight">\(\sigma_{nc}=0.25\ nm\)</span>. The values of the torsional <span class="math notranslate nohighlight">\(k_t\)</span> and native energy constant <span class="math notranslate nohighlight">\(\epsilon_{c}\)</span> are assigned by the following equations:</p>
<div class="math notranslate nohighlight">
\[k_t=N_{atoms}/3N_{torsions}\ (kJ/mol)\]</div>
<div class="math notranslate nohighlight">
\[k_c=2N_{atoms}/3N_{contacts}\ (kJ/mol)\]</div>
<p>Where <span class="math notranslate nohighlight">\(N_{atoms}\)</span> is the total number of atoms in the system, <span class="math notranslate nohighlight">\(N_{torsions}\)</span> is the total number of proper torsions assigned by the forcefield and <span class="math notranslate nohighlight">\(N_{contacts}\)</span> is the number of native contacts in the contact file definition. Additionally, the torsional energy constant <span class="math notranslate nohighlight">\(k_t\)</span> is further divided by classifying the torsions into backbone and sidechain groups. The assignment is carried out as:</p>
<div class="math notranslate nohighlight">
\[k_{t}^{bb}=2k_t/3\]</div>
<div class="math notranslate nohighlight">
\[k_{t}^{sc}=k_t/3\]</div>
<p>Here, <span class="math notranslate nohighlight">\(k_{t}^{bb}\)</span> and <span class="math notranslate nohighlight">\(k_{t}^{sc}\)</span> are the torsional energy constant for backbone and sidechain torsion groups, respectively. This grouping of torsions into backbone and side chains is the default behaviour of the sbmOpenMM.models.getAllAtomModel() method. It can be disabled by given the option group_by_bb_and_sc=False.</p>
<p>The geometric parameters are set to the calculated structural values in the input structure, with <span class="math notranslate nohighlight">\(r_0\)</span> the equilibrium bond distance in nanometers, <span class="math notranslate nohighlight">\(\theta_0\)</span> the equilibrium angle length in radians, <span class="math notranslate nohighlight">\(\phi_0\)</span> the equilibrium torsional angle in radians, <span class="math notranslate nohighlight">\(\chi_0\)</span> the equilibrium improper or planar equilibrium angle in radians and <span class="math notranslate nohighlight">\(\sigma_{ij}\)</span> the equilibrium contact distance in nanometers. The variable <span class="math notranslate nohighlight">\(r\)</span> represents, accordingly, the current bond or (non)contact distance in nanometers, <span class="math notranslate nohighlight">\(\theta\)</span> the current angle length in radians, <span class="math notranslate nohighlight">\(\phi\)</span> the current proper torsional angle in radians and <span class="math notranslate nohighlight">\(\chi\)</span> the equilibrium improper or planar torsional angles in radians.</p>
<p>Note that even if the units for the force constants are given in real physical units (e.g. <span class="math notranslate nohighlight">\(kJ/mol\)</span>), this is just to match the variables used by OpenMM. The models are not parametrized to equate this real physical values and comparison with experiments will require further adjustment to the energy unit system.</p>
</div>
<div class="section" id="multi-basin-model">
<h3>Multi basin model<a class="headerlink" href="#multi-basin-model" title="Permalink to this headline">¶</a></h3>
<p>The multi basin model automates the creation of a dual basin native contact potential. It receives as input two sbmOpenMM system classes, either CA or AA models, containing two different definitions of native contacts. One of the configurations is defined as the main model and the other is considered as the alternate model. All forcefield and topology parameters, different than the native contacts, are passed from the main configuration into the multi basin model. Then, the contacts are compared between the input configurations to define the sets of common and unique contacts. Common contacts with equilibrium length distances that differ more than a threshold are defined as dual basin and are assigned a special non-bonded Gaussian potential. The rest of the contacts are treated as single minima and are modeled with a Lennard-Jones (default) or a single basin Gaussian potential.</p>
<p>The multi basin Gaussian potential is defined as:</p>
<div class="math notranslate nohighlight">
\[V_{Multi-basin} = \epsilon_{C}((1+(\frac{r_{ex}}{r})^{12})\prod_{minima}G(r,r_{0}^{\alpha})-1)\]</div>
<div class="math notranslate nohighlight">
\[G(r,r_{0}^{\alpha}) = 1-exp(\frac{-(r-r_{0}^{\alpha})^2}{2\sigma^2})\]</div>
<div class="math notranslate nohighlight">
\[\sigma^{2} = \frac{(r_{0}^{\alpha})^2}{50ln(2)}\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\epsilon_{C}\)</span> is the native contact energy constant inherited from the main configuration, <span class="math notranslate nohighlight">\(r_{ex}\)</span> is the contact excluded volume radius, <span class="math notranslate nohighlight">\(r_{0}^{\alpha}\)</span> is the equilibrium distance for the <span class="math notranslate nohighlight">\(alpha\)</span>-th configuration and <span class="math notranslate nohighlight">\(r\)</span> is the current contact distance. <span class="math notranslate nohighlight">\(\sigma\)</span> is a parameter that modulates the well amplitude of the <span class="math notranslate nohighlight">\(V_{Multi-basin}\)</span> energy function. The single and double basin gaussian potential are distinguished by the number of <span class="math notranslate nohighlight">\(r_{0}^{\alpha}\)</span> parameters given.</p>
<p>The Lennard Jones contact potential is inherited accordingly from the CA or AA models used to build the multi basin SBM.</p>
<p>The method to create a multi basin model is:</p>
<p>sbmOpenMM.models.getMultiBasinModel(main_model, alternate_configuration=alternate_model)</p>
<p>Here, main_model and alternate_model are initialized sbmOpenMM system classes containing full force field parameter definitions.</p>
</div>
</div>
<div class="section" id="core-classes">
<h2>Core classes<a class="headerlink" href="#core-classes" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-core"></span><p>core package of the sbmOpenMM package that contains the main sbmOpenMM classes.</p>
<p>The sbmOpenMM.core package contains the three sbmOpenMM main classes:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>geometry</p></li>
<li><p>models</p></li>
<li><p>system</p></li>
</ol>
</div></blockquote>
<p>The first class, geometry, contains methods to calculate the geometrical parameters from the input structures. These parameters are used to define the input conformation as the global minimum configuration in the potential energy function. The second class, models, allows to easily set up predefined SBM models, that encompass coarse grained, all atom and multi basin potentials. The third class, system, is the main class that holds all the methods to define, modify and create SBMs to be simulated with OpenMM.</p>
<dl class="class">
<dt id="core.geometry">
<em class="property">class </em><code class="sig-name descname">geometry</code><a class="reference internal" href="_modules/core/geometry.html#geometry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to hold methods for calculating geometrical values 
given sets of atom coordinates.</p>
<dl class="method">
<dt id="core.geometry.angle">
<code class="sig-name descname">angle</code><span class="sig-paren">(</span><em class="sig-param">coord1</em>, <em class="sig-param">coord2</em>, <em class="sig-param">coord3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/geometry.html#geometry.angle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.geometry.angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the angle length between three (x,y,z) quantity coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coord1</strong><span class="classifier">simtk.unit.quantity.Quantity array</span></dt><dd><p>Vector for the first coordinate.</p>
</dd>
<dt><strong>coord2</strong><span class="classifier">simtk.unit.quantity.Quantity array</span></dt><dd><p>Vector for the second coordinate.</p>
</dd>
<dt><strong>coord3</strong><span class="classifier">simtk.unit.quantity.Quantity array</span></dt><dd><p>Vector for the third coordinate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>simtk.unit.quantity.Quantity</dt><dd><p>Quantity (value and unit) of the angle length in radians.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.geometry.bond">
<code class="sig-name descname">bond</code><span class="sig-paren">(</span><em class="sig-param">coord1</em>, <em class="sig-param">coord2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/geometry.html#geometry.bond"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.geometry.bond" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the distance length between two (x,y,z) quantity coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coord1</strong><span class="classifier">simtk.unit.quantity.Quantity array</span></dt><dd><p>Vector for the first coordinate.</p>
</dd>
<dt><strong>coord2</strong><span class="classifier">simtk.unit.quantity.Quantity array</span></dt><dd><p>Vector for the second coordinate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>simtk.unit.quantity.Quantity</dt><dd><p>Quantity (value and unit) of the distance length in nanometers.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.geometry.position2Array">
<code class="sig-name descname">position2Array</code><span class="sig-paren">(</span><em class="sig-param">position</em>, <em class="sig-param">output_unit</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/geometry.html#geometry.position2Array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.geometry.position2Array" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an OpenMM position object quantity into a numpy array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>position</strong><span class="classifier">simtk.unit.quantity.Quantity</span></dt><dd><p>Array containing quantity objects [e.g. (x,y,z) array returned
from positions].</p>
</dd>
<dt><strong>output_unit</strong><span class="classifier">simtk.unit.unit.Unit</span></dt><dd><p>Unit in which to return the items of the array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>A numpy array containing the quantity values converted to floats.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.geometry.torsion">
<code class="sig-name descname">torsion</code><span class="sig-paren">(</span><em class="sig-param">coord1</em>, <em class="sig-param">coord2</em>, <em class="sig-param">coord3</em>, <em class="sig-param">coord4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/geometry.html#geometry.torsion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.geometry.torsion" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the torsion angle length between four (x,y,z) quantity 
coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coord1</strong><span class="classifier">simtk.unit.quantity.Quantity array</span></dt><dd><p>Vector for the first coordinate.</p>
</dd>
<dt><strong>coord2</strong><span class="classifier">simtk.unit.quantity.Quantity array</span></dt><dd><p>Vector for the second coordinate.</p>
</dd>
<dt><strong>coord3</strong><span class="classifier">simtk.unit.quantity.Quantity array</span></dt><dd><p>Vector for the third coordinate.</p>
</dd>
<dt><strong>coord4</strong><span class="classifier">simtk.unit.quantity.Quantity array</span></dt><dd><p>Vector for the fourth coordinate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>simtk.unit.quantity.Quantity</dt><dd><p>Quantity (value and unit) of the torsion length in radians.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-core"></span><p>core package of the sbmOpenMM package that contains the main sbmOpenMM classes.</p>
<p>The sbmOpenMM.core package contains the three sbmOpenMM main classes:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>geometry</p></li>
<li><p>models</p></li>
<li><p>system</p></li>
</ol>
</div></blockquote>
<p>The first class, geometry, contains methods to calculate the geometrical parameters from the input structures. These parameters are used to define the input conformation as the global minimum configuration in the potential energy function. The second class, models, allows to easily set up predefined SBM models, that encompass coarse grained, all atom and multi basin potentials. The third class, system, is the main class that holds all the methods to define, modify and create SBMs to be simulated with OpenMM.</p>
<dl class="class">
<dt id="core.models">
<em class="property">class </em><code class="sig-name descname">models</code><a class="reference internal" href="_modules/core/models.html#models"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.models" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to hold functions for the automated generation of default SBM models.</p>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 42%" />
<col style="width: 58%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>getAllAtomModel(pdb_file, contact_file, kwarg</strong>)**</p></td>
<td><p>Creates an all atom SBM system class object with default initialized parameters.</p></td>
</tr>
<tr class="row-even"><td><p><strong>getCAModel(pdb_file, contact_file, kwarg</strong>)**</p></td>
<td><p>Creates an alpha-carbon only sbmOpenMM system class object with default initialized parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>getMultiBasinModel(main_model, alternate_configuration, kwarg</strong>)**</p></td>
<td><p>Creates a multi basin model from two sbmOpenMM.system class instances.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="core.models.getAllAtomModel">
<code class="sig-name descname">getAllAtomModel</code><span class="sig-paren">(</span><em class="sig-param">pdb_file</em>, <em class="sig-param">contact_file</em>, <em class="sig-param">default_parameters=True</em>, <em class="sig-param">default_forces=True</em>, <em class="sig-param">group_by_bb_and_sc=True</em>, <em class="sig-param">create_system=True</em>, <em class="sig-param">minimise=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/models.html#models.getAllAtomModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.models.getAllAtomModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialises a default full-heavy-atom sbmOpenMM system class from a PDB file and a contact
file defining the native contacts for the model. The system creation steps are:</p>
<ol class="arabic simple">
<li><p>Add the geometrical parameters for the model.</p></li>
<li><p>Add the default force field parameters for the model.</p></li>
<li><p>Create the default force objects.</p></li>
<li><p>Create the OpenMM system class.</p></li>
</ol>
<p>The method can be used to generate an initialized sbmOpenMM system class, that only 
contains the geometrical parameters, by passing the option default_parameters as False.
This is useful to store the geometrical values of bonds, angles, dihedrals, etc. in 
order to add custom parameters and forces.</p>
<p>The method can also be created without the initialisation of the forces classes by 
setting default_forces to False. This allows to load the default forcefield parameters 
and to modified them before creating the OpenMM force objects.</p>
<p>Finally, the method can be stopped before creating the OpenMM system class using create_system=False.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pdb_file</strong><span class="classifier">string</span></dt><dd><p>Path to the input PDB file.</p>
</dd>
<dt><strong>contact_file</strong><span class="classifier">string</span></dt><dd><p>Path to the input native contact file. The file can be an output 
from the SMOG program (4 column contact file) or a two column file 
defining the atoms to be paired.</p>
</dd>
<dt><strong>default_parameters</strong><span class="classifier">boolean (True)</span></dt><dd><p>Whether to add default SBM All Atom forcefield parameters to the model.</p>
</dd>
<dt><strong>default_forces</strong><span class="classifier">boolean (True)</span></dt><dd><p>Whether to initilize default SBM All Atom force objects. Set to False if
the parameters will be different from the default ones.</p>
</dd>
<dt><strong>group_by_bb_and_sc</strong><span class="classifier">boolean (True)</span></dt><dd><p>Wether to classify the torsions into backbone and side-chain to partition 
the torsional energy for each torsion in the system.</p>
</dd>
<dt><strong>create_system</strong><span class="classifier">boolean (True)</span></dt><dd><p>If True the function will call the createSystemObject() method
to create an OpenMM system object. If modifications to the default 
forcefield are necessary this option should be given False.</p>
</dd>
<dt><strong>minimise</strong><span class="classifier">boolean (False)</span></dt><dd><p>Whether to minimise the system (with default options) if large
forces are found.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sbm</strong><span class="classifier">sbmOpenMM.system</span></dt><dd><p>Initializes a sbmOpenMM.system class with default options for 
defining an All Atom SBM force field.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.models.getCAModel">
<code class="sig-name descname">getCAModel</code><span class="sig-paren">(</span><em class="sig-param">pdb_file</em>, <em class="sig-param">contact_file</em>, <em class="sig-param">default_parameters=True</em>, <em class="sig-param">default_forces=True</em>, <em class="sig-param">create_system=True</em>, <em class="sig-param">contact_force='12-10'</em>, <em class="sig-param">minimise=False</em>, <em class="sig-param">residue_masses=False</em>, <em class="sig-param">residue_radii=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/models.html#models.getCAModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.models.getCAModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialises a coarse-grained, carbon alpha (CA), sbmOpenMM system class 
from a PDB file and a contact file defining the native contacts for the 
coarse grained model.</p>
<p>The system creation steps are:</p>
<ol class="arabic simple">
<li><p>Add the geometrical parameters for the model.</p></li>
<li><p>Add the default force field parameters for the model.</p></li>
<li><p>Create the default force objects.</p></li>
<li><p>Create the OpenMM system class.</p></li>
</ol>
<p>The method can be used to generate an initialized sbmOpenMM system class, that only 
contains the geometrical parameters, by passing the option default_parameters as False.
This is useful to store the geometrical values of bonds, angles, dihedrals, etc. in 
order to add custom parameters and forces.</p>
<p>The method can also be created without the initialisation of the forces classes by 
setting default_forces to False. This allows to load the default forcefield parameters 
and to modified them before creating the OpenMM force objects.</p>
<p>Finally, the method can be stopped before creating the OpenMM system class using create_system=False.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pdb_file</strong><span class="classifier">string</span></dt><dd><p>Path to the input PDB file.</p>
</dd>
<dt><strong>contact_file</strong><span class="classifier">string</span></dt><dd><p>Path to the input native contact file. The file can be an output 
from the SMOG program (4 column contact file) or a two column file 
defining the atoms to be paired.</p>
</dd>
<dt><strong>default_parameters</strong><span class="classifier">boolean (True)</span></dt><dd><p>Whether to add default SBM CA forcefield parameters to the model.</p>
</dd>
<dt><strong>default_forces</strong><span class="classifier">boolean (True)</span></dt><dd><p>Whether to initilize default SBM CA force objects. Set to False if
the parameters will be different from the default ones.</p>
</dd>
<dt><strong>create_system</strong><span class="classifier">boolean (True)</span></dt><dd><p>If True the function will call the createSystemObject() method
to create an OpenMM system object. If modifications to the default 
forcefield are necessary this option should be given False.</p>
</dd>
<dt><strong>residue_masses</strong><span class="classifier">boolean (False)</span></dt><dd><p>Set each alpha carbon atom mass to its average aminoacid residue mass.</p>
</dd>
<dt><strong>residue_radii</strong><span class="classifier">boolean (False)</span></dt><dd><p>Set each alpha carbon atom radius to its statistical aminoacid residue radius.</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>sbm</strong><span class="classifier">sbmOpenMM.system</span></dt><dd><p>Initialized sbmOpenMM.system class with default options for defining 
a coarse-grained CA SBM force field.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.models.getMultiBasinModel">
<code class="sig-name descname">getMultiBasinModel</code><span class="sig-paren">(</span><em class="sig-param">main_model</em>, <em class="sig-param">alternate_configuration</em>, <em class="sig-param">double_minima_threshold=0.05</em>, <em class="sig-param">excluded_volume_radius=None</em>, <em class="sig-param">use_lennard_jones=True</em>, <em class="sig-param">create_system=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/models.html#models.getMultiBasinModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.models.getMultiBasinModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a multibasin model from two sbmOpenMM initialized system classes.
It currently supports only two configurations.</p>
<p>The two configurations (main and alternate) are compared at the level of 
native contacts to define common and unique contacts. If any common contact
is defined to have equilibrium distances significantly different between the 
configurations, a multi basin Gaussian potential is added to explicitely consider 
both equilibrium distances in the non-bonded energy function. Unique contacts 
from the alternate configuration are added to the main configuration. All other
bonded parameters are maintained from the main configuration.</p>
<p>Optionally, an excluded volume term can be given, with the excluded_volume_radius
option, to control separately the sphere radius from the equilibrium contact distances.</p>
<p>The set of single-basin (or unique) contacts are added, by default, as Lennard-Jones
potentials (use_lennard_jones=True) or can be added as Gaussian terms (use_lennard_jones=False)
with separate control of the excluded volume term.</p>
<p>Finally, the method can be stopped before creating the OpenMM system class using
create_system=False.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>main_model</strong><span class="classifier">sbmOpenMM.system</span></dt><dd><p>Configuration upon which the multi basin forces should be added.</p>
</dd>
<dt><strong>alternate_configuration</strong><span class="classifier">sbmOpenMM.system</span></dt><dd><p>Second configuration to define as a new minima in the native contact force
object.</p>
</dd>
<dt><strong>double_minima_threshold</strong><span class="classifier">float</span></dt><dd><p>The minimum equilibrium distance difference to consider a native contact having 
two different equilibrium distances. If shared contacts between the configurations 
have equilibrium distances that do not differ more than this value, only the main 
configuration equilibrium distance will be  kept.</p>
</dd>
<dt><strong>excluded_volume_radius</strong><span class="classifier">float</span></dt><dd><p>Radius of the excluded volume term in the Gaussian native-contact energy function.</p>
</dd>
<dt><strong>use_lennard_jones</strong><span class="classifier">boolean (True)</span></dt><dd><p>Whether to use or not Lennard-Jones potential for the single-basin native contact
set. If False a Gaussian function with separate control of the excluded volume term.</p>
</dd>
<dt><strong>create_system</strong><span class="classifier">boolean (True)</span></dt><dd><p>If True the function will call the createSystemObject() method
to create an OpenMM system object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sbm</strong><span class="classifier">sbmOpenMM.system</span></dt><dd><p>Initialized sbmOpenMM.system class with added multi basin contact potential.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>common_contacts</strong><span class="classifier">set</span></dt><dd><p>Set containing the common contacts between configurations.</p>
</dd>
<dt><strong>dual_basin_contacts</strong><span class="classifier">set</span></dt><dd><p>Set containing the subset of common contacts that have a dual basin potential</p>
</dd>
<dt><strong>unique_contacts</strong><span class="classifier">dict</span></dt><dd><p>Dictionary containing the sets of unique contacts for each configuration. The keys are 
integers, 0 for the main configuration, 1 for the alternate configuration.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-core"></span><p>core package of the sbmOpenMM package that contains the main sbmOpenMM classes.</p>
<p>The sbmOpenMM.core package contains the three sbmOpenMM main classes:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>geometry</p></li>
<li><p>models</p></li>
<li><p>system</p></li>
</ol>
</div></blockquote>
<p>The first class, geometry, contains methods to calculate the geometrical parameters from the input structures. These parameters are used to define the input conformation as the global minimum configuration in the potential energy function. The second class, models, allows to easily set up predefined SBM models, that encompass coarse grained, all atom and multi basin potentials. The third class, system, is the main class that holds all the methods to define, modify and create SBMs to be simulated with OpenMM.</p>
<dl class="class">
<dt id="core.system">
<em class="property">class </em><code class="sig-name descname">system</code><span class="sig-paren">(</span><em class="sig-param">pdb_path</em>, <em class="sig-param">particles_mass=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system" title="Permalink to this definition">¶</a></dt>
<dd><p>A class containing methods and parameters for generating Structure Based
Models (SBM) systems to be simulated using the OpenMM interface. It offers 
flexibility to create default and custom SBM systems and to easily 
modify their parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pdb_path</strong><span class="classifier">string</span></dt><dd><p>Path to the pdb input file</p>
</dd>
<dt><strong>pdb</strong><span class="classifier">openmm.app.pdbfile.PDBFile</span></dt><dd><p>Object that holds the information of OpenMM PDB parsing method.</p>
</dd>
<dt><strong>topology</strong><span class="classifier">openmm.app.topology.Topology</span></dt><dd><p>OpenMM topology of the model.</p>
</dd>
<dt><strong>positions</strong><span class="classifier">unit.quantity.Quantity</span></dt><dd><p>Atomic positions of the model.</p>
</dd>
<dt><strong>particles_mass</strong><span class="classifier">float or list</span></dt><dd><p>Mass of each particle. If float then uniform masses are given to all 
particles. If list per-particle masses are assigned.</p>
</dd>
<dt><strong>model_type</strong><span class="classifier">string</span></dt><dd><p>String representing the model type: All-atom (AA), alpha-carbon (CA)
or multi-basin variants (AA-MB, CA-MB).</p>
</dd>
<dt><strong>atoms</strong><span class="classifier">list</span></dt><dd><p>A list of the current atoms in the model. The items are simtk.openmm.app.topology.Atom
initialised classes.</p>
</dd>
<dt><strong>n_atoms</strong><span class="classifier">int</span></dt><dd><p>Total numer of atoms in the model.</p>
</dd>
<dt><strong>bonds</strong><span class="classifier">collections.OrderedDict</span></dt><dd><p>A dict that uses bonds (2-tuple of simtk.openmm.app.topology.Atom objects) 
present in the model as keys and their forcefield properties as values.</p>
</dd>
<dt><strong>bonds_indexes</strong><span class="classifier">list</span></dt><dd><p>A list containing the zero-based indexes of the atoms defining the bonds in the model.</p>
</dd>
<dt><strong>n_bonds</strong><span class="classifier">int</span></dt><dd><p>Total numer of bonds in the model.</p>
</dd>
<dt><strong>angles</strong><span class="classifier">collections.OrderedDict</span></dt><dd><p>A dict that uses angles (3-tuple of simtk.openmm.app.topology.Atom objects)
present in the model as keys and their forcefield properties as values.</p>
</dd>
<dt><strong>angles_indexes</strong><span class="classifier">list</span></dt><dd><p>A list containing the zero-based indexes of the atoms defining the angles in the model.</p>
</dd>
<dt><strong>n_angles</strong><span class="classifier">int</span></dt><dd><p>Total numer of angles in the model.</p>
</dd>
<dt><strong>torsions</strong><span class="classifier">collections.OrderedDict</span></dt><dd><p>A dict that uses proper torsions (4-tuple of simtk.openmm.app.topology.Atom objects) 
present in the model as keys and their forcefield properties as values.</p>
</dd>
<dt><strong>torions_indexes</strong><span class="classifier">list</span></dt><dd><p>A list containing the zero-based indexes of the atoms defining the torsions in the model.</p>
</dd>
<dt><strong>n_torsions</strong><span class="classifier">int</span></dt><dd><p>Total numer of proper torsions in the model.</p>
</dd>
<dt><strong>impropers</strong><span class="classifier">collections.OrderedDict</span></dt><dd><p>A dict that uses improper torsions (4-tuple of simtk.openmm.app.topology.Atom objects)
present in the model as keys and their forcefield properties as values.</p>
</dd>
<dt><strong>impropers_indexes</strong><span class="classifier">list</span></dt><dd><p>A list containing the zero-based indexes of the atoms defining the imporpers in the model.</p>
</dd>
<dt><strong>n_impropers</strong><span class="classifier">int</span></dt><dd><p>Total numer of improper torsions in the model.</p>
</dd>
<dt><strong>planars</strong><span class="classifier">collections.OrderedDict</span></dt><dd><p>A dict that uses planar torsions (4-tuple of simtk.openmm.app.topology.Atom objects)
present in the model as keys and their forcefield properties as values.</p>
</dd>
<dt><strong>planars_indexes</strong><span class="classifier">list</span></dt><dd><p>A list containing the zero-based indexes of the atoms defining the planars in the model.</p>
</dd>
<dt><strong>n_planars</strong><span class="classifier">int</span></dt><dd><p>Total numer of planar torsions in the model.</p>
</dd>
<dt><strong>contacts</strong><span class="classifier">collections.OrderedDict</span></dt><dd><p>A dict that uses native contacts (2-tuple of simtk.openmm.app.topology.Atom objects
present in the model as keys and their forcefield properties as values.</p>
</dd>
<dt><strong>contacts_indexes</strong><span class="classifier">list</span></dt><dd><p>A list containing the zero-based indexes of the atoms defining the contacts in the model.</p>
</dd>
<dt><strong>n_contacts</strong><span class="classifier">int</span></dt><dd><p>Total numer of native contacts in the model.</p>
</dd>
<dt><strong>torsions_group</strong><span class="classifier">dict</span></dt><dd><p>A dict that uses proper torsions two central atoms (2-tuple of simtk.openmm.app.topology.Atom objects)
present in the model’s topology as keys and the number of torsions (int) that share these same middle 
bond atoms as values.</p>
</dd>
<dt><strong>torsions_type</strong><span class="classifier">dict</span></dt><dd><p>A dict that uses proper torsions (4-tuple of simtk.openmm.app.topology.Atom objects)
present in the model as keys and, a string representing wheter the torsion 
is classified as ‘backbone’ or ‘sidechain’ as values.</p>
</dd>
<dt><strong>energy_constant</strong><span class="classifier">dict</span></dt><dd><p>A dict that holds the value for the different energy terms parameters
used by different SBM models and forces.</p>
</dd>
<dt><strong>harmonicBondForce</strong><span class="classifier">openmm.HarmonicBondForce</span></dt><dd><p>Stores the OpenMM HarmonicBondForce initialised-class. Implements
an harmonic bond potential between pairs of particles, that depends
quadratically on their distance.</p>
</dd>
<dt><strong>harmonicAngleForce</strong><span class="classifier">openmm.HarmonicAngleForce</span></dt><dd><p>Stores the OpenMM HarmonicAngleForce initialised-class. Implements
an harmonic angle potential between trios of particles, that depends
quadratically on their angle length.</p>
</dd>
<dt><strong>periodicTorsionForce</strong><span class="classifier">openmm.CustomTorsionForce</span></dt><dd><p>Stores the OpenMM CustomTorsionForce initialised-class. Implements 
a force potential that varies periodically with the value of the 
proper torsion angle.</p>
</dd>
<dt><strong>generalPeriodicTorsionForce</strong><span class="classifier">openmm.CustomTorsionForce</span></dt><dd><p>Stores the OpenMM CustomTorsionForce initialised-class. Implements 
a general force potential that varies periodically with the value of the 
proper torsion angle.</p>
</dd>
<dt><strong>harmonicImproperForce</strong><span class="classifier">openmm.CustomTorsionForce</span></dt><dd><p>Stores the OpenMM CustomTorsionForce initialised-class. Implements 
a force potential that varies quadratically with the value of the  
improper torsion angle.</p>
</dd>
<dt><strong>harmonicPlanarForce</strong><span class="classifier">openmm.CustomTorsionForce</span></dt><dd><p>Stores the OpenMM CustomTorsionForce initialised-class. Implements 
a force potential that varies quadratically with the value of the  
planar torsion angle.</p>
</dd>
<dt><strong>lj12_6contactForce</strong><span class="classifier">openmm.CustomBondForce</span></dt><dd><p>Stores the OpenMM CustomBondForce initialised-class to be applied
to non-bonded interactions between native contact pairs. Implements 
a lennard-jones potential with exponents 12 and 6 for the repulsive
and attractive componenets, respectively.</p>
</dd>
<dt><strong>lj12_10contactForce</strong><span class="classifier">openmm.CustomBondForce</span></dt><dd><p>Stores the OpenMM CustomBondForce initialised-class to be applied
to non-bonded interactions between native contact pairs. Implements 
a lennard-jones potential with exponents 12 and 10 for the repulsive
and attractive components, respectively.</p>
</dd>
<dt><strong>lj12_10_6contactForce</strong><span class="classifier">openmm.CustomBondForce</span></dt><dd><p>Stores the OpenMM CustomBondForce initialised-class to be applied
to non-bonded interactions between native contact pairs. Implements 
a lennard-jones potential with exponents 12 and 10 for the repulsive
and attractive components, respectively, and an additional 6-exponent 
term to model a “desolvation penalty” for forming/breaking contacts.</p>
</dd>
<dt><strong>singleGaussianContactForce</strong><span class="classifier">openmm.CustomNonbondedForce</span></dt><dd><p>Stores the OpenMM CustomBondForce initialised-class to be applied
to non-bonded interactions between native contact pairs with single
minimum. Implements a mixed lennard-jones (repulsive) and gaussian
potential (attractive) with separate control of equilibrium distance
and excluded volume.</p>
</dd>
<dt><strong>doubleGaussianContactForce</strong><span class="classifier">openmm.CustomNonbondedForce</span></dt><dd><p>Stores the OpenMM CustomBondForce initialised-class to be applied
to non-bonded interactions between native contact pairs with two 
minima. Implements a mixed lennard-jones (repulsive) and gaussian
potential (attractive) with separate control of the equilibrium 
distances and excluded volume.</p>
</dd>
<dt><strong>ljRepulsionForce</strong><span class="classifier">openmm.CustomNonbondedForce</span></dt><dd><p>Stores the OpenMM CustomBondForce initialised-class to be applied
to the non-bonded interactions between non-native contact pairs. 
Implements only a repulsive lennard-jones potential with exponent 
12.</p>
</dd>
<dt><strong>forceGroups</strong><span class="classifier">collections.OrderedDict</span></dt><dd><p>A dict that uses force names as keys and their corresponding force
as values.</p>
</dd>
<dt><strong>system</strong><span class="classifier">openmm.System</span></dt><dd><p>Stores the OpenMM System initialised class. It stores all the forcefield
information for the SBM model.</p>
</dd>
<dt><strong>rf_epsilon</strong><span class="classifier">float</span></dt><dd><p>Epsilon parameter used in the repulsion force object.</p>
</dd>
<dt><strong>rf_sigma</strong><span class="classifier">float</span></dt><dd><p>Sigma parameter used in the repulsion force object.</p>
</dd>
<dt><strong>rf_cutoff</strong><span class="classifier">float</span></dt><dd><p>Cutoff value used for repulsion force interactions.</p>
</dd>
<dt><strong>exclusions</strong><span class="classifier">list</span></dt><dd><p>List of added exclusions for the repuslion non-bonded term.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>removeHydrogens()</strong></p></td>
<td><p>Remove hydrogens from the input pdb by using a regexpression pattern. Used specially for creating all atom (AA) models.</p></td>
</tr>
<tr class="row-even"><td><p><strong>getCAlphaOnly()</strong></p></td>
<td><p>Filter in only alpha carbon atoms from the input pdb and updates the topology object to add new bonds between them. Used specially for creating alpha-carbon (CA) corse-grained models.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>getAtoms()</strong></p></td>
<td><p>Reads atoms from topology, adds them to the main class and sorts them into a dictionary to store their forcefield properties.</p></td>
</tr>
<tr class="row-even"><td><p><strong>getBonds()</strong></p></td>
<td><p>Reads bonds from topology, adds them to the main class and sorts them into a dictionary to store their forcefield properties.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>getAngles()</strong></p></td>
<td><p>Reads bonds from topology and creates a list of all possible angles, adds them to the main class and sorts them into a dictionary to store their forcefield properties.</p></td>
</tr>
<tr class="row-even"><td><p><strong>getProperTorsions()</strong></p></td>
<td><p>Using the created angles, usually by the getAngles() method, creates a list of all possible proper torsion dihedral angles, filtering out torsions based on residue-specific rules (only for the all-atom model). The torsions are then added to the main class and sorted into a dictionary to store their forcefield properties.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>getImpropers()</strong></p></td>
<td><p>Create improper torsions based on backbone and sidechain residue-specific rules (all-atom model only), adds them to the main class and sorts them into a dictionary to store their forcefield properties.</p></td>
</tr>
<tr class="row-even"><td><p><strong>getPlanars()</strong></p></td>
<td><p>Create planar torsions based on backbone and sidechain residue-specific rules (all-atom model only), adds them to the main class and sorts them into a dictionary to store their forcefield properties.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>readContactFile()</strong></p></td>
<td><p>Reads a file containing native contact information and adds it into the main class. The file can be smog-style (4 columns) or given as 2 columns. The format will be automatically detected.</p></td>
</tr>
<tr class="row-even"><td><p><strong>setBondParameters()</strong></p></td>
<td><p>Change the forcefield parameters for bonded terms.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>setAngleParameters()</strong></p></td>
<td><p>Change the forcefield parameters for angle terms.</p></td>
</tr>
<tr class="row-even"><td><p><strong>setProperTorsionParameters()</strong></p></td>
<td><p>Change the forcefield parameters for proper torsion terms.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>setImproperParameters()</strong></p></td>
<td><p>Change the forcefield parameters for improper torsion terms.</p></td>
</tr>
<tr class="row-even"><td><p><strong>setPlanarParameters()</strong></p></td>
<td><p>Change the forcefield parameters for planar torsion terms.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>setNativeContactParameters()</strong></p></td>
<td><p>Change the forcefield parameters for native contact terms.</p></td>
</tr>
<tr class="row-even"><td><p><strong>setParticlesMasses()</strong></p></td>
<td><p>Change the mass parameter for each atom in the system.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>setParticlesRadii()</strong></p></td>
<td><p>Change the excluded volume radius parameter for each atom in the system.</p></td>
</tr>
<tr class="row-even"><td><p><strong>addHarmonicBondForces()</strong></p></td>
<td><p>Creates an harmonic bonded force term for each bond in the main class using their defined forcefield parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>addHarmonicAngleForces()</strong></p></td>
<td><p>Creates an harmonic angle force term for each angle in the main class using their defined forcefield parameters.</p></td>
</tr>
<tr class="row-even"><td><p><strong>addPeriodicTorsionForces()</strong></p></td>
<td><p>Creates a periodic torsion force term for each proper torsion in the main class using their defined forcefield parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>addGenericPeriodicTorsionForces()</strong></p></td>
<td><p>Creates a periodic torsion force term for each proper torsion in the main class using their defined forcefield parameters.</p></td>
</tr>
<tr class="row-even"><td><p><strong>addHarmonicImproperForces()</strong></p></td>
<td><p>Creates an harmonic torsion force term for each improper torsion in the main class using their defined forcefield parameters. Used specially for simulating All Atom systems.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>addHarmonicPlanarForces()</strong></p></td>
<td><p>Creates an harmonic torsion force term for each planar torsion in the main class using their defined forcefield parameters. Used specially for simulating All Atom systems.</p></td>
</tr>
<tr class="row-even"><td><p><strong>addLJ12_6ContactForces()</strong></p></td>
<td><p>Creates a 12-6 Lennard-Jones bond potential for each native contact in the main class using their defined forcefield parameters. Used specially for simulating All Atom systems.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>addLJ12_10ContactForces()</strong></p></td>
<td><p>Creates a 12-10 Lennard-Jones bond potential for each native contact in the main class using their defined forcefield parameters. Used specially for simulating coarse-grained alpha-carbon systems.</p></td>
</tr>
<tr class="row-even"><td><p><strong>addGaussianContactForces()</strong></p></td>
<td><p>Creates a gaussian single and double basin bond potential for each native contact in the main class using their defined forcefield parameters. The contacts are recognized according two the number of parameters given as values in the attribute system. 3-parameters for single-basin potential and 4-paramters for dual-basin potentials.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>addLJRepulsionForces()</strong></p></td>
<td><p>Creates a repulsive-only 12 Lennard-Jones non-bonded potential specifying a exclusion list for bond, angle, torsion, and native contact terms.</p></td>
</tr>
<tr class="row-even"><td><p><strong>groupTorsionsbyBBAndSC()</strong></p></td>
<td><p>Groups proper torsions by backbone and sidechain torsions. Used exclusively for simulating all-atom SBM.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>getAATorsionParameters()</strong></p></td>
<td><p>Generates default periodic torsion forcefield parameters, for proper torsions, using pre-defined assignment schemes. Used exclusively for simulating all-atom SBM.</p></td>
</tr>
<tr class="row-even"><td><p><strong>getAANativeContactParameters()</strong></p></td>
<td><p>Generates default bonded contact forcefield parameters, for native contacts, using pre-defined assignment schemes. Used exclusively for simulating all-atom SBM.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>createSystemObject()</strong></p></td>
<td><p>Creates OpenMM system object adding particles, masses and forces. It also groups the added forces into Force-Groups for the sbmReporter class.</p></td>
</tr>
<tr class="row-even"><td><p><strong>addParticles()</strong></p></td>
<td><p>Add particles to the system OpenMM class instance.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>addSystemForces()</strong></p></td>
<td><p>Add forces to the system OpenMM class instance. It also save names for the added forces to include them in the reporter class.</p></td>
</tr>
<tr class="row-even"><td><p><strong>dumpPdb()</strong></p></td>
<td><p>Writes a PDB file of the system in its current state.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>dumpForceFieldData()</strong></p></td>
<td><p>Writes to a file the parameters of the SBM forcefield.</p></td>
</tr>
<tr class="row-even"><td><p><strong>loadForcefieldFromFile()</strong></p></td>
<td><p>Loads forcefield parameters from a sbmOpenMM force field file written with the dumpForceFieldData() method.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>setCAMassPerResidueType()</strong></p></td>
<td><p>Sets alpha carbon atoms to their average residue mass. Used specially for modifying alpha-carbon (CA) corse-grained models.</p></td>
</tr>
<tr class="row-even"><td><p><strong>setCARadiusPerResidueType()</strong></p></td>
<td><p>Sets alpha carbon atoms to their average residue mass. Used specially for modifying alpha-carbon (CA) corse-grained models.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="core.system.addGaussianContactForces">
<code class="sig-name descname">addGaussianContactForces</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.addGaussianContactForces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.addGaussianContactForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an openmm.CustomBondForce() object with the equilibrium 
distances and parameters setted up in the “contacts” attribute. 
Two forces are created according to the number of parameters given:</p>
<p>If three parameters are given the custom bond force is initilized 
with the formula:</p>
<p>energy = epsilon*((1+(r0/r)^12)*(1-exp(-25*log(2)*(r-r0)^2/(r0*r0)))-1)</p>
<p>The force object is stored at the “singleGaussianContactForce” attribute.</p>
<p>The force parameters must be contained in self.contacts as follows:
self.contacts is a dictionary:</p>
<blockquote>
<div><ul class="simple">
<li><p>The keys are tuples for tww atoms in self.topology.atoms attribute.</p></li>
<li><dl class="simple">
<dt>The values are a tuple of parameters in the following order:</dt><dd><p>first  -&gt; rex (float)
second -&gt; r0 (quantity)
third -&gt; epsilon (float)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>If four parameters are given the custom bond force is initilized 
with the formula:</p>
<dl class="simple">
<dt>energy = epsilon*((1+(r0/r)^12)*(1-exp(-25*log(2)*(r-r0)^2/(r0*r0)))*</dt><dd><p>(1-exp(-25*log(2)*(r-r1)^2/(r1*r1)))-1)</p>
</dd>
</dl>
<p>The force object is stored at the “doubleGaussianContactForce” attribute.</p>
<p>The force parameters must be contained in self.contacts as follows:
self.contacts is a dictionary:</p>
<blockquote>
<div><ul class="simple">
<li><p>The keys are tuples for two atoms in self.topology.atoms attribute.</p></li>
<li><dl class="simple">
<dt>The values are a tuple of parameters in the following order:</dt><dd><p>first  -&gt; rex (float)
second -&gt; r0 (quantity)
second -&gt; r1 (quantity)
third -&gt; epsilon (float)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.addGeneralPeriodicTorsionForces">
<code class="sig-name descname">addGeneralPeriodicTorsionForces</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.addGeneralPeriodicTorsionForces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.addGeneralPeriodicTorsionForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an openmm.CustomTorsionForce() object with the torsions 
and parameters setted up in the “torsions” attribute. The custom 
torsion force is initilized with the formula:</p>
<p>energy = k*(1+cos(n*(theta-theta0)))</p>
<p>The force object is stored at the “generalPeriodicTorsionForce” attribute.</p>
<p>The force parameters must be contained in self.torsions as follows:
self.torsions is a dictionary:</p>
<blockquote>
<div><ul>
<li><p>The keys are tuples for four atoms in self.topology.atoms attribute.</p></li>
<li><p>The values are a list with the parameters as items:
Each item is a tuple containing:</p>
<blockquote>
<div><p>first  -&gt; theta0 (quantity)
second -&gt; k (float)
third -&gt; n (int)</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.addHarmonicAngleForces">
<code class="sig-name descname">addHarmonicAngleForces</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.addHarmonicAngleForces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.addHarmonicAngleForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an openmm.HarmonicAngleForce() object with the angles and 
parameters setted up in the “angles” attribute. The force object 
is stored at the “harmonicAngleForce” attribute.</p>
<p>The force parameters must be contained in self.angles as follows:
self.angles is dictionary:</p>
<blockquote>
<div><ul class="simple">
<li><p>The keys are 3-tuples for three atoms in self.topology.atoms attribute.</p></li>
<li><dl class="simple">
<dt>The values are a 2-tuple of parameters in the following order:</dt><dd><p>first  -&gt; angle0 (quantity)
second -&gt; k (float)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.addHarmonicBondForces">
<code class="sig-name descname">addHarmonicBondForces</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.addHarmonicBondForces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.addHarmonicBondForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an openmm.HarmonicBondForce() object with the bonds and 
parameters setted up in the “bonds” dictionary attribute. The force object 
is stored at the “harmonicBondForce” attribute.</p>
<p>The force parameters must be contained in self.bonds as follows:
self.bonds is a dictionary:</p>
<blockquote>
<div><ul class="simple">
<li><p>The keys are 2-tuples for two atom items in self.topology.atoms attribute.</p></li>
<li><dl class="simple">
<dt>The values are a 2-tuple of parameters in the following order:</dt><dd><p>first  -&gt; bond0 (quantity)
second -&gt; k (float)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.addHarmonicImproperForces">
<code class="sig-name descname">addHarmonicImproperForces</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.addHarmonicImproperForces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.addHarmonicImproperForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an openmm.CustomTorsionForce() object with the torsions 
and parameters setted up in the “impropers” attribute. The custom 
torsion force is initilized with the formula:</p>
<p>energy = 0.5*k*dtheta_torus^2
dtheta_torus = dtheta - floor(dtheta/(2*pi)+0.5)*(2*pi)
dtheta = theta - theta0
pi = np.pi</p>
<p>The force object is stored at the “harmonicImproperForce” attribute.</p>
<p>The force parameters must be contained in self.torsions as follows:
self.torsions is a dictionary:</p>
<blockquote>
<div><ul class="simple">
<li><p>The keys are tuples for four atoms in self.topology.atoms attribute.</p></li>
<li><dl class="simple">
<dt>The values are a tuple of parameters in the following order:</dt><dd><p>first  -&gt; theta0 (quantity)
second -&gt; k (float)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.addHarmonicPlanarForces">
<code class="sig-name descname">addHarmonicPlanarForces</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.addHarmonicPlanarForces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.addHarmonicPlanarForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an openmm.CustomTorsionForce() object with the torsions 
and parameters setted up in the “planars” attribute. The custom 
torsion force is initilized with the formula:</p>
<p>energy = 0.5*k*dtheta_torus^2
dtheta_torus = dtheta - floor(dtheta/(2*pi)+0.5)*(2*pi)
dtheta = theta - theta0
pi = np.pi</p>
<p>The force object is stored at the “harmonicPlanarForce” attribute.</p>
<p>The force parameters must be contained in self.torsions as follows:
self.torsions is a dictionary:</p>
<blockquote>
<div><ul class="simple">
<li><p>The keys are tuples for four atoms in self.topology.atoms attribute.</p></li>
<li><dl class="simple">
<dt>The values are a tuple of parameters in the following order:</dt><dd><p>first  -&gt; theta0 (quantity)
second -&gt; k (float)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.addLJ12_10ContactForces">
<code class="sig-name descname">addLJ12_10ContactForces</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.addLJ12_10ContactForces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.addLJ12_10ContactForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an openmm.CustomBondForce() object with the bonds and 
parameters setted up in the “contacts” attribute. The custom 
bond force is initilized with the formula:</p>
<p>energy = epsilon*(5*(sigma/r)^12-6*(sigma/r)^10)</p>
<p>The force object is stored at the “lj12_10contactForce” attribute.</p>
<p>The force parameters must be contained in self.contacts as follows:
self.contacts is a dictionary:</p>
<blockquote>
<div><ul class="simple">
<li><p>The keys are tuples for two atoms in self.topology.atoms attribute.</p></li>
<li><dl class="simple">
<dt>The values are a tuple of parameters in the following order:</dt><dd><p>first  -&gt; sigma (quantity)
second -&gt; epsilon (float)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.addLJ12_10_6ContactForces">
<code class="sig-name descname">addLJ12_10_6ContactForces</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.addLJ12_10_6ContactForces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.addLJ12_10_6ContactForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an openmm.CustomBondForce() object with the bonds and 
parameters setted up in the “contacts” attribute. The custom 
bond force is initilized with the formula:</p>
<p>energy = epsilon*(13*(sigma/r)^12-18*(sigma/r)^10+4*(sigma/r)^6)</p>
<p>The force object is stored at the “lj12_10_6contactForce” attribute.</p>
<p>The force parameters must be contained in self.contacts as follows:
self.contacts is an ordered dictionary:</p>
<blockquote>
<div><ul class="simple">
<li><p>The keys are tuples for two atoms in self.topology.atoms attribute.</p></li>
<li><dl class="simple">
<dt>The values are a tuple of parameters in the following order:</dt><dd><p>first  -&gt; sigma (quantity)
second -&gt; epsilon (float)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.addLJ12_6ContactForces">
<code class="sig-name descname">addLJ12_6ContactForces</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.addLJ12_6ContactForces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.addLJ12_6ContactForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an openmm.CustomBondForce() object with the bonds and 
parameters setted up in the “contacts” attribute. The custom 
bond force is initilized with the formula:</p>
<p>energy = epsilon*((sigma/r)^12-2*(sigma/r)^6)</p>
<p>The force object is stored at the “lj12_6contactForce” attribute.</p>
<p>The force parameters must be contained in self.contacts as follows:
self.contacts is a dictionary:</p>
<blockquote>
<div><ul class="simple">
<li><p>The keys are tuples for two atoms in self.topology.atoms attribute.</p></li>
<li><dl class="simple">
<dt>The values are a tuple of parameters in the following order:</dt><dd><p>first  -&gt; sigma (quantity)
second -&gt; epsilon (float)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.addLJRepulsionForces">
<code class="sig-name descname">addLJRepulsionForces</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">cutoff=None</em>, <em class="sig-param">bonded_exclusions_index=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.addLJRepulsionForces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.addLJRepulsionForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an openmm.CustomNonbondedForce() object with the parameters 
sigma and epsilon given to this method. The custom non-bonded force
is initilized with the formula:</p>
<p>energy = ‘epsilon*(sigma/r)^12; sigma=0.5*(sigma1+sigma2)’</p>
<p>The method adds exclusions for bonded atoms up until ‘bonded_exclusions_index’ 
bond orders (default 3) and also for all the pairs defined in the ‘contacts’ attribute. 
The force object is stored at the “ljRepulsionForce” attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>epsilon</strong><span class="classifier">float</span></dt><dd><p>Value of the epsilon constant in the energy function.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float or list</span></dt><dd><p>Value of the sigma constant (in nm) in the energy function. If float the
same sigma value is used for every particle. If list a unique 
parameter is given for each particle.</p>
</dd>
<dt><strong>cutoff</strong><span class="classifier">float</span></dt><dd><p>The cutoff distance (in nm) being used for the nonbonded interactions.</p>
</dd>
<dt><strong>bonded_exclusions_index</strong><span class="classifier">int</span></dt><dd><p>Specified number of bonds to consider when adding non-bonded exclusions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.addParticles">
<code class="sig-name descname">addParticles</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.addParticles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.addParticles" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a particle to the sbmOpenMM system for each atom in it. The mass 
of each particle is set up with the values in the ‘particles_mass’ 
attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.addPeriodicTorsionForces">
<code class="sig-name descname">addPeriodicTorsionForces</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.addPeriodicTorsionForces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.addPeriodicTorsionForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an openmm.CustomTorsionForce() object with the torsions 
and parameters setted up in the “torsions” attribute. The custom 
torsion force is initilized with the formula:</p>
<p>energy = k*(1-cos(theta-theta0)+0.5*(1-cos(3*(theta-theta0))))</p>
<p>The force object is stored at the “periodicTorsionForce” attribute.</p>
<p>The force parameters must be contained in self.torsions as follows:
self.torsions is a dictionary:</p>
<blockquote>
<div><ul class="simple">
<li><p>The keys are tuples for four atoms in self.topology.atoms attribute.</p></li>
<li><dl class="simple">
<dt>The values are a tuple of parameters in the following order:</dt><dd><p>first  -&gt; theta0 (quantity)
second -&gt; k (float)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.addSystemForces">
<code class="sig-name descname">addSystemForces</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.addSystemForces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.addSystemForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds generated forces to the sbmOpenMM system, also adding 
a force group to the ‘forceGroups’ attribute dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.checkBondDistances">
<code class="sig-name descname">checkBondDistances</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">threshold=0.25</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.checkBondDistances"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.checkBondDistances" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches for large bond distances for the atom pairs defined in 
the ‘bonds’ attribute. It raises an error when large bonds are found.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>Treshold to check for large bond distances.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.checkLargeForces">
<code class="sig-name descname">checkLargeForces</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">threshold=1</em>, <em class="sig-param">minimise=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.checkLargeForces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.checkLargeForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the SBM system energies of the input configuration of the 
system. It optionally checks for large forces acting upon all 
particles in the SBM system and iteratively minimises the system
configuration until no forces larger than a threshold are found.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>Treshold to check for large forces.</p>
</dd>
<dt><strong>minimise</strong><span class="classifier">float</span></dt><dd><p>Whether to iteratively minimise the system until all forces are lower or equal to 
the thresshold value.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.createSystemObject">
<code class="sig-name descname">createSystemObject</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">check_bond_distances=True</em>, <em class="sig-param">minimise=False</em>, <em class="sig-param">force_threshold=10</em>, <em class="sig-param">bond_threshold=0.25</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.createSystemObject"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.createSystemObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an openmm.System() object using the force field parameters
given to the SBM ‘system’ class. It adds particles, forces and 
creates a force group for each force object. Optionally the method 
can check for large bond distances (default) and minimise the atomic 
positions if large forces are found in any atom (default False).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>minimise</strong><span class="classifier">boolean</span></dt><dd><p>Wheter to minimise the system if large forces are found.</p>
</dd>
<dt><strong>check_bond_distances</strong><span class="classifier">boolean</span></dt><dd><p>Wheter to check for large bond distances.</p>
</dd>
<dt><strong>force_threshold</strong><span class="classifier">float</span></dt><dd><p>Treshold to check for large forces.</p>
</dd>
<dt><strong>bond_threshold</strong><span class="classifier">float</span></dt><dd><p>Treshold to check for large bond distances.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.dumpForceFieldData">
<code class="sig-name descname">dumpForceFieldData</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">output_file</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.dumpForceFieldData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.dumpForceFieldData" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes a file containing the current forcefield parameters in the 
sbmOpenMM system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>output_file</strong><span class="classifier">string</span></dt><dd><p>name of the output file.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.dumpPdb">
<code class="sig-name descname">dumpPdb</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">output_file</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.dumpPdb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.dumpPdb" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes a PDB file containing the currently defined abmOpenMM system atoms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>output_file</strong><span class="classifier">string</span></dt><dd><p>name of the PDB output file.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.getAANativeContactParameters">
<code class="sig-name descname">getAANativeContactParameters</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.getAANativeContactParameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.getAANativeContactParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the contact force field parameters by distributing the 
total native contact energy equally among all the contacts.</p>
<p>The energy values are stored in the ‘energy_constant’ attribute, 
which contains the entry ‘C’ for the partitioned energy values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>contact_parameters</strong><span class="classifier">list</span></dt><dd><p>List of the native-contact force constant parameters for each 
native contact in the SBM system.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.getAATorsionParameters">
<code class="sig-name descname">getAATorsionParameters</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">group_by_bb_and_sc=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.getAATorsionParameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.getAATorsionParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the torsion force field parameters by distributing the 
total torsional energy equally among all the torsions. Optionally,
uses torsional classifications, in backbone or side-chain torsions,
to group the energy partition. In the last case considers that BB
torsion energies are twice the value of sidechain torsion energies.</p>
<p>The energy partioned values are stored in the ‘energy_constant’ 
attribute. It contains the entries ‘torsion’ for the equally partitioned
torsion energies, or ‘BB’ and ‘SC’ for group-partioned torsion energies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>group_by_bb_and_sc</strong><span class="classifier">boolean</span></dt><dd><p>Wheter to partion the torsional energy in backbone and side-chain 
groups.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>torsion_parameters</strong><span class="classifier">list</span></dt><dd><p>List of the torsion force constant parameters for each torsion
in the SBM system.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.getAngles">
<code class="sig-name descname">getAngles</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.getAngles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.getAngles" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds angles to the sbmOpenMM system class based on the bondings in the topology 
object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.getAtoms">
<code class="sig-name descname">getAtoms</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.getAtoms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.getAtoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds atoms in the OpenMM topology instance to the sbmOpenMM system class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.getBonds">
<code class="sig-name descname">getBonds</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.getBonds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.getBonds" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds bonds in the OpenMM topology instance to the sbmOpenMM system class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.getCAlphaOnly">
<code class="sig-name descname">getCAlphaOnly</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.getCAlphaOnly"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.getCAlphaOnly" title="Permalink to this definition">¶</a></dt>
<dd><p>Keeps in the SBM system only the alpha carbon atoms from the OpenMM topology.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.getImpropers">
<code class="sig-name descname">getImpropers</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.getImpropers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.getImpropers" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds improper torsions to the sbmOpenMM system class to maintain backbone 
chiralities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.getPlanars">
<code class="sig-name descname">getPlanars</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.getPlanars"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.getPlanars" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds planar torsions to the sbmOpenMM system class to mantain side chain and 
backbone planar arrangements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.getProperTorsions">
<code class="sig-name descname">getProperTorsions</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.getProperTorsions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.getProperTorsions" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds proper torsions to the sbmOpenMM system class based on the bonded angles
in it. Excludes special torsions for rings and backbones.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.groupTorsionsbyBBAndSC">
<code class="sig-name descname">groupTorsionsbyBBAndSC</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.groupTorsionsbyBBAndSC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.groupTorsionsbyBBAndSC" title="Permalink to this definition">¶</a></dt>
<dd><p>Classifies the torsions into backbone or sidechain, based on the atoms 
present in each torsion definition.</p>
<p>The classification is stored in the ‘torsions_type’ dictionary attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.loadForcefieldFromFile">
<code class="sig-name descname">loadForcefieldFromFile</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">forcefield_file</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.loadForcefieldFromFile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.loadForcefieldFromFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads force field parameters from a force field file written by the 
dumpForceFieldData() method into the sbmOpenMM system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>forcefield_file</strong><span class="classifier">string</span></dt><dd><p>path to the force field file.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.readContactFile">
<code class="sig-name descname">readContactFile</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">contact_file</em>, <em class="sig-param">shift=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.readContactFile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.readContactFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads a file to add native contact information to the sbmOpenMM system class.
The file format can be ‘smog’ like (i.e. 4 columns) or ‘2column’ like
(i.e. one column for each atom). This is auto-dected by the method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.removeHydrogens">
<code class="sig-name descname">removeHydrogens</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.removeHydrogens"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.removeHydrogens" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all hydrogen atoms in the topology from the SBM system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.setAngleParameters">
<code class="sig-name descname">setAngleParameters</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">angle_parameters</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.setAngleParameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.setAngleParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the harmonic angle constant force parameters. The input can 
be a float, to set the same parameter for all force interactions, 
or a list, to define a unique parameter for each force interaction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>angle_parameters</strong><span class="classifier">float or list</span></dt><dd><p>Parameter(s) to set up for the harmonic angle forces.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.setBondParameters">
<code class="sig-name descname">setBondParameters</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">bond_parameters</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.setBondParameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.setBondParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the harmonic bond constant force parameters. The input can be 
a float, to set the same parameter for all force interactions, or 
a list, to define a unique parameter for each force interaction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bond_parameters</strong><span class="classifier">float or list</span></dt><dd><p>Parameter(s) to set up for the harmonic bond forces.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.setCAMassPerResidueType">
<code class="sig-name descname">setCAMassPerResidueType</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.setCAMassPerResidueType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.setCAMassPerResidueType" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the masses of the alpha carbon atoms to the average mass
of its amino acid residue.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.setCARadiusPerResidueType">
<code class="sig-name descname">setCARadiusPerResidueType</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.setCARadiusPerResidueType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.setCARadiusPerResidueType" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the excluded volume radii of the alpha carbon atoms 
to characteristic radii of their corresponding amino acid 
residue.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.setImproperParameters">
<code class="sig-name descname">setImproperParameters</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">improper_parameters</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.setImproperParameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.setImproperParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the harmonic torsion constant force parameters for impropers. 
The input can be a float, to set the same parameter for all force 
interactions, or a list, to define a unique paremater for each force 
interaction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>improper_parameters</strong><span class="classifier">float or list</span></dt><dd><p>Parameter(s) to set up for the harmonic torsion force parameters 
for impropers.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.setNativeContactParameters">
<code class="sig-name descname">setNativeContactParameters</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">contact_parameters</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.setNativeContactParameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.setNativeContactParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the native interactions constant force parameters for native 
contacts. The input can be a float, to set the same parameter for 
all force interactions, or a list, to define a unique parameter 
for each force interaction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>contact_parameters</strong><span class="classifier">float or list</span></dt><dd><p>Parameter(s) to set up for the native interaction force for 
native contacts.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.setParticlesMasses">
<code class="sig-name descname">setParticlesMasses</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">particles_mass</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.setParticlesMasses"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.setParticlesMasses" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the masses of the particles in the system. The input can be a 
float, to set the same mass for all particles, or a list, to define 
a unique mass for each particle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>particles_mass</strong><span class="classifier">float or list</span></dt><dd><p>Mass(es) values to add for the particles in the sbmOpenMM system class.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.setParticlesRadii">
<code class="sig-name descname">setParticlesRadii</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">particles_radii</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.setParticlesRadii"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.setParticlesRadii" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the radii of the particles in the system. The input can be a 
float, to set the same radius for all particles, or a list, to define 
a unique radius for each particle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>particles_radii</strong><span class="classifier">float or list</span></dt><dd><p>Radii values to add for the particles in the sbmOpenMM system class.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.setPlanarParameters">
<code class="sig-name descname">setPlanarParameters</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">planar_parameters</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.setPlanarParameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.setPlanarParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the harmonic torsion constant force parameters for planars. 
The input can be a float, to set the same parameter for all force 
interactions, or a list, to define a unique parameter for each force 
interaction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>planar_parameters</strong><span class="classifier">float or list</span></dt><dd><p>Parameter(s) to set up for the harmonic torsion force parameters 
for planars.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="core.system.setProperTorsionParameters">
<code class="sig-name descname">setProperTorsionParameters</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">torsion_parameters</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/core/system.html#system.setProperTorsionParameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#core.system.setProperTorsionParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the periodic torsion constant force parameters. The input can 
be a float, to set the same parameter for all force interactions, 
or a list, to define a unique parameter for each force interaction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>torsion_parameters</strong><span class="classifier">float or list</span></dt><dd><p>Parameter(s) to set up for the periodic torsion forces.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="reporter-class">
<h2>Reporter class<a class="headerlink" href="#reporter-class" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-reporter"></span><p>reporter package of the sbmOpenMM package that contains the sbmReporter class.</p>
<p>The sbmOpenMM.reproter package contains the sbmReporter class.</p>
<p>sbmReporter is a special class of the OpenMM StateDataReporter class, that additionally
accepts a sbmobject to print the SBM forcefield energies.</p>
<dl class="class">
<dt id="reporter.sbmReporter">
<em class="property">class </em><code class="sig-name descname">sbmReporter</code><span class="sig-paren">(</span><em class="sig-param">file</em>, <em class="sig-param">reportInterval</em>, <em class="sig-param">sbmObject=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/reporter/sbm_reporter.html#sbmReporter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#reporter.sbmReporter" title="Permalink to this definition">¶</a></dt>
<dd><p>A special case of the StateDataReporter class that outputs information about a simulation, 
such as energy and temperature, etc. to a file. This special reporter outputs the sbmOpenMM 
force group energies inside the sbmOpenMM system object.</p>
<p>It is used in the same way as the OpenMM StateDataReporter class, but it takes as additional
input an instance of the sbmOpenMM object with the option ‘sbmObject’.</p>
</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">sbmOpenMM Documentation</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#sbm-models">SBM Models</a><ul>
<li><a class="reference internal" href="#coarse-grained-alpha-carbon-ca-model">Coarse grained, alpha-carbon (CA), model</a></li>
<li><a class="reference internal" href="#all-heavy-atoms-aa-model">All-heavy-atoms (AA) model</a></li>
<li><a class="reference internal" href="#multi-basin-model">Multi basin model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#core-classes">Core classes</a></li>
<li><a class="reference internal" href="#reporter-class">Reporter class</a></li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, "Martin Floor, Kengjie Li".
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>